import { Meta } from '@storybook/addon-docs';
import tokens from '../compiled/tokens/js/tokens';
const ratio = tokens.number.scale.modular.ratio.value;
const minimumStep = tokens.number.scale.modular.minimum_step.value;
const maximumStep = tokens.number.scale.modular.maximum_step.value;
const sizeRows = [];
for (let i = minimumStep; i <= maximumStep; i++) {
  // `toFixed` keeps the values from extending past two decimal points.
  // The `Number` constructor prevents unnecessary decimals from displaying,
  // for example `1.00` instead of `1`.
  const size = `${Number((ratio ** i).toFixed(2))}em`;
  const row = (
    <tr>
      <td>{i}</td>
      <td>{size}</td>
      <td style={{ width: '90%' }}>
        <div
          style={{
            background: 'currentColor',
            height: '1em',
            opacity: 0.66,
            width: size,
          }}
        ></div>
      </td>
    </tr>
  );
  sizeRows.push(row);
}

<Meta title="Design/Modular Scale" />

# Modular Scale

Most typographic and whitespace measurements in our patterns are based on steps of [our modular scale](/docs/design-tokens-modular-scale--page). This has several benefits for text-heavy projects like ours:

- Encourages designers to think in terms of relative proportion rather than hard-set sizes, which makes patterns more versatile in responsive designs.
- Minimizes loss of text alignment in complex layouts.
- Avoids the need to define every step of a scale individually.
- Ensures the relationship between successive steps is predictable and clear.

To learn more about modular scales, we recommend reading [More Meaningful Typography](https://alistapart.com/article/more-meaningful-typography/) by Tim Brown.

## Sizes

<table>
  <thead>
    <tr>
      <th>Step</th>
      <th>Size</th>
      <th></th>
    </tr>
  </thead>
  <tbody>{sizeRows}</tbody>
</table>
